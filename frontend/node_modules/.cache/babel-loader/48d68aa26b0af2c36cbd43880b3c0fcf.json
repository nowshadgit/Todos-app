{"ast":null,"code":"import { __extends, __read, __spread } from \"tslib\";\nimport AnalyticsEvent from './AnalyticsEvent';\n\nvar UIAnalyticsEvent =\n/** @class */\nfunction (_super) {\n  __extends(UIAnalyticsEvent, _super);\n\n  function UIAnalyticsEvent(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.clone = function () {\n      if (_this.hasFired) {\n        // eslint-disable-next-line no-console\n        console.warn(\"Cannot clone an event after it's been fired.\");\n        return null;\n      }\n\n      var context = __spread(_this.context);\n\n      var handlers = __spread(_this.handlers);\n      /**\n       * A hacky \"deep clone\" of the object. This is limited in that it wont\n       * support functions, regexs, Maps, Sets, etc, but none of those need to\n       * be represented in our payload.\n       */\n\n\n      var payload = JSON.parse(JSON.stringify(_this.payload));\n      return new UIAnalyticsEvent({\n        context: context,\n        handlers: handlers,\n        payload: payload\n      });\n    };\n\n    _this.fire = function (channel) {\n      if (_this.hasFired) {\n        // eslint-disable-next-line no-console\n        console.warn('Cannot fire an event twice.');\n        return;\n      }\n\n      _this.handlers.forEach(function (handler) {\n        return handler(_this, channel);\n      });\n\n      _this.hasFired = true;\n    };\n\n    _this.context = props.context || [];\n    _this.handlers = props.handlers || [];\n    _this.hasFired = false;\n    return _this;\n  }\n\n  UIAnalyticsEvent.prototype.update = function (updater) {\n    if (this.hasFired) {\n      // eslint-disable-next-line no-console\n      console.warn(\"Cannot update an event after it's been fired.\");\n      return this;\n    }\n\n    return _super.prototype.update.call(this, updater);\n  };\n\n  return UIAnalyticsEvent;\n}(AnalyticsEvent);\n\nexport default UIAnalyticsEvent;","map":null,"metadata":{},"sourceType":"module"}