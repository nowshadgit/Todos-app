{"ast":null,"code":"import { __assign, __extends, __read, __spread } from \"tslib\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport UIAnalyticsEvent from './UIAnalyticsEvent';\n/**\n * This component is used to grab the analytics functions off context.\n * It uses legacy context, but provides an API similar to 16.3 context.\n * This makes it easier to use with the forward ref API.\n */\n\nvar AnalyticsContextConsumer =\n/** @class */\nfunction (_super) {\n  __extends(AnalyticsContextConsumer, _super);\n\n  function AnalyticsContextConsumer(props) {\n    var _this = _super.call(this, props) || this;\n    /**\n     * Store references to the original and patched event props so we can\n     * determine when to update the patched props\n     */\n\n\n    _this.originalEventProps = {};\n    _this.patchedEventProps = {}; // Update patched event props only if the original props have changed\n\n    _this.updatePatchedEventProps = function (props) {\n      var changedPropCallbacks = Object.keys(_this.props.createEventMap).filter(function (p) {\n        return _this.originalEventProps[p] !== props[p];\n      });\n\n      if (changedPropCallbacks.length > 0) {\n        _this.patchedEventProps = __assign(__assign({}, _this.patchedEventProps), _this.mapCreateEventsToProps(changedPropCallbacks, props));\n        changedPropCallbacks.forEach(function (p) {\n          _this.originalEventProps[p] = props[p];\n        });\n      }\n\n      return _this.patchedEventProps;\n    };\n\n    _this.mapCreateEventsToProps = function (changedPropNames, props) {\n      return changedPropNames.reduce(function (modified, propCallbackName) {\n        var _a;\n\n        var eventCreator = _this.props.createEventMap[propCallbackName];\n        var providedCallback = props[propCallbackName];\n\n        if (!['object', 'function'].includes(typeof eventCreator)) {\n          return modified;\n        }\n\n        var modifiedCallback = function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          var analyticsEvent = typeof eventCreator === 'function' ? eventCreator(_this.createAnalyticsEvent, props) : _this.createAnalyticsEvent(eventCreator);\n\n          if (providedCallback) {\n            providedCallback.apply(void 0, __spread(args, [analyticsEvent]));\n          }\n        };\n\n        return __assign(__assign({}, modified), (_a = {}, _a[propCallbackName] = modifiedCallback, _a));\n      }, {});\n    };\n\n    _this.createAnalyticsEvent = function (payload) {\n      var _a = _this.context,\n          getAtlaskitAnalyticsEventHandlers = _a.getAtlaskitAnalyticsEventHandlers,\n          getAtlaskitAnalyticsContext = _a.getAtlaskitAnalyticsContext;\n      return new UIAnalyticsEvent({\n        context: typeof getAtlaskitAnalyticsContext === 'function' && getAtlaskitAnalyticsContext() || [],\n        handlers: typeof getAtlaskitAnalyticsEventHandlers === 'function' && getAtlaskitAnalyticsEventHandlers() || [],\n        payload: payload\n      });\n    };\n\n    Object.keys(_this.props.createEventMap).forEach(function (p) {\n      _this.originalEventProps[p] = props.wrappedComponentProps[p];\n    });\n    _this.patchedEventProps = _this.mapCreateEventsToProps(Object.keys(_this.props.createEventMap), props.wrappedComponentProps);\n    return _this;\n  }\n\n  AnalyticsContextConsumer.prototype.render = function () {\n    var patchedEventProps = this.updatePatchedEventProps(this.props.wrappedComponentProps);\n    return this.props.children({\n      createAnalyticsEvent: this.createAnalyticsEvent,\n      patchedEventProps: patchedEventProps\n    });\n  };\n\n  AnalyticsContextConsumer.contextTypes = {\n    getAtlaskitAnalyticsEventHandlers: PropTypes.func,\n    getAtlaskitAnalyticsContext: PropTypes.func\n  };\n  AnalyticsContextConsumer.defaultProps = {\n    createEventMap: {}\n  };\n  return AnalyticsContextConsumer;\n}(React.Component);\n\nexport default AnalyticsContextConsumer;","map":null,"metadata":{},"sourceType":"module"}