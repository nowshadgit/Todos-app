{"ast":null,"code":"/* eslint-disable react/require-default-props */\nimport { __assign, __extends } from \"tslib\";\nimport React from 'react';\nimport NodeResolver from 'react-node-resolver';\nimport flushable from 'flushable';\nimport { Popper } from '@atlaskit/popper';\nimport Portal from '@atlaskit/portal';\nimport { layers } from '@atlaskit/theme/constants';\nimport { withAnalyticsEvents, withAnalyticsContext, createAndFireEvent } from '@atlaskit/analytics-next';\nimport { name as packageName, version as packageVersion } from '../version.json';\nimport { Tooltip as StyledTooltip } from '../styled';\nimport Animation from './Animation';\nimport { hoveredPayload, unhoveredPayload } from './utils/analytics-payloads';\nvar SCROLL_OPTIONS = {\n  capture: true,\n  passive: true\n};\n\nfunction getMousePosition(mouseCoordinates) {\n  var safeMouse = mouseCoordinates || {\n    top: 0,\n    left: 0\n  };\n\n  var getBoundingClientRect = function () {\n    return {\n      top: safeMouse.top,\n      left: safeMouse.left,\n      bottom: safeMouse.top,\n      right: safeMouse.left,\n      width: 0,\n      height: 0\n    };\n  };\n\n  return {\n    getBoundingClientRect: getBoundingClientRect,\n    clientWidth: 0,\n    clientHeight: 0\n  };\n}\n\nvar pendingHide;\n\nvar showTooltip = function (fn, defaultDelay) {\n  var isHidePending = pendingHide && pendingHide.pending();\n\n  if (isHidePending) {\n    pendingHide.flush();\n  }\n\n  var pendingShow = flushable(function () {\n    return fn(isHidePending);\n  }, isHidePending ? 0 : defaultDelay);\n  return pendingShow.cancel;\n};\n\nvar hideTooltip = function (fn, defaultDelay) {\n  pendingHide = flushable(function (flushed) {\n    return fn(flushed);\n  }, defaultDelay);\n  return pendingHide.cancel;\n};\n\nvar Tooltip =\n/** @class */\nfunction (_super) {\n  __extends(Tooltip, _super);\n\n  function Tooltip() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.cancelPendingSetState = function () {}; // set in mouseover/mouseout handlers\n\n\n    _this.state = {\n      immediatelyHide: false,\n      immediatelyShow: false,\n      isVisible: false,\n      renderTooltip: false\n    };\n\n    _this.handleWindowScroll = function () {\n      if (_this.state.isVisible) {\n        _this.cancelPendingSetState();\n\n        _this.setState({\n          isVisible: false,\n          immediatelyHide: true\n        });\n      }\n    };\n\n    _this.handleMouseClick = function () {\n      if (_this.props.hideTooltipOnClick) {\n        _this.cancelPendingSetState();\n\n        _this.setState({\n          isVisible: false,\n          immediatelyHide: true\n        });\n      }\n    };\n\n    _this.handleMouseDown = function () {\n      if (_this.props.hideTooltipOnMouseDown) {\n        _this.cancelPendingSetState();\n\n        _this.setState({\n          isVisible: false,\n          immediatelyHide: true\n        });\n      }\n    };\n\n    _this.handleMouseOver = function (e) {\n      if (e.target === _this.wrapperRef) return; // In the case where a tooltip is newly rendered but immediately becomes hovered,\n      // we need to set the coordinates in the mouseOver event.\n\n      if (!_this.fakeMouseElement) _this.fakeMouseElement = getMousePosition({\n        left: e.clientX,\n        top: e.clientY\n      });\n\n      _this.cancelPendingSetState();\n\n      if (Boolean(_this.props.content) && !_this.state.isVisible) {\n        _this.cancelPendingSetState = showTooltip(function (immediatelyShow) {\n          _this.setState({\n            isVisible: true,\n            renderTooltip: true,\n            immediatelyShow: immediatelyShow\n          });\n        }, _this.props.delay || 0);\n      }\n    };\n\n    _this.handleMouseLeave = function (e) {\n      if (e.target === _this.wrapperRef) return;\n\n      _this.cancelPendingSetState();\n\n      if (_this.state.isVisible) {\n        _this.cancelPendingSetState = hideTooltip(function (immediatelyHide) {\n          _this.setState({\n            isVisible: false,\n            immediatelyHide: immediatelyHide\n          });\n        }, _this.props.delay || 0);\n      }\n    }; // Update mouse coordinates, used when position is 'mouse'.\n    // We are not debouncing/throttling this function because we aren't causing any\n    // re-renders or performaing any intensive calculations, we're just updating a value.\n    // React also doesn't play nice debounced DOM event handlers because they pool their\n    // SyntheticEvent objects. Need to use event.persist as a workaround - https://stackoverflow.com/a/24679479/893630\n\n\n    _this.handleMouseMove = function (event) {\n      if (!_this.state.renderTooltip) {\n        _this.fakeMouseElement = getMousePosition({\n          left: event.clientX,\n          top: event.clientY\n        });\n      }\n    };\n\n    return _this;\n  }\n\n  Tooltip.prototype.componentWillUnmount = function () {\n    this.cancelPendingSetState();\n    this.removeScrollListener();\n  };\n\n  Tooltip.prototype.componentDidUpdate = function (_prevProps, prevState) {\n    if (!prevState.isVisible && this.state.isVisible) {\n      if (this.props.onShow) this.props.onShow();\n      window.addEventListener('scroll', this.handleWindowScroll, SCROLL_OPTIONS);\n    } else if (prevState.isVisible && !this.state.isVisible) {\n      if (this.props.onHide) this.props.onHide();\n      this.removeScrollListener();\n    }\n  };\n\n  Tooltip.prototype.removeScrollListener = function () {\n    window.removeEventListener('scroll', this.handleWindowScroll, SCROLL_OPTIONS);\n  };\n\n  Tooltip.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        children = _a.children,\n        content = _a.content,\n        position = _a.position,\n        mousePosition = _a.mousePosition,\n        truncate = _a.truncate,\n        TooltipContainer = _a.component,\n        TargetContainer = _a.tag,\n        testId = _a.testId;\n    var _b = this.state,\n        isVisible = _b.isVisible,\n        renderTooltip = _b.renderTooltip,\n        immediatelyShow = _b.immediatelyShow,\n        immediatelyHide = _b.immediatelyHide;\n    return (\n      /* eslint-disable jsx-a11y/mouse-events-have-key-events */\n      React.createElement(React.Fragment, null, TargetContainer && React.createElement(TargetContainer, {\n        onClick: this.handleMouseClick,\n        onMouseOver: this.handleMouseOver,\n        onMouseOut: this.handleMouseLeave,\n        onMouseMove: this.handleMouseMove,\n        onMouseDown: this.handleMouseDown,\n        ref: function (wrapperRef) {\n          _this.wrapperRef = wrapperRef;\n        }\n      }, React.createElement(NodeResolver, {\n        innerRef: function (targetRef) {\n          _this.targetRef = targetRef;\n        }\n      }, React.Children.only(children))), renderTooltip && this.targetRef && this.fakeMouseElement ? React.createElement(Portal, {\n        zIndex: layers.tooltip()\n      }, React.createElement(Popper // @ts-ignore\n      , {\n        // @ts-ignore\n        referenceElement: // https://github.com/FezVrasta/react-popper#usage-without-a-reference-htmlelement\n        // We are using a popper technique to pass in a faked element when we use mouse.\n        // This is fine.\n        position === 'mouse' ? this.fakeMouseElement : this.targetRef,\n        placement: position === 'mouse' ? mousePosition : position\n      }, function (_a) {\n        var ref = _a.ref,\n            style = _a.style,\n            placement = _a.placement;\n        return TooltipContainer && React.createElement(Animation, {\n          immediatelyShow: immediatelyShow,\n          immediatelyHide: immediatelyHide,\n          onExited: function () {\n            return _this.setState({\n              renderTooltip: false\n            });\n          },\n          in: isVisible\n        }, function (getAnimationStyles) {\n          return React.createElement(TooltipContainer, {\n            innerRef: ref,\n            className: \"Tooltip\",\n            style: __assign(__assign({}, getAnimationStyles(placement)), style),\n            truncate: truncate || false,\n            \"data-testid\": testId\n          }, content);\n        });\n      })) : null)\n      /* eslint-enable */\n\n    );\n  };\n\n  Tooltip.defaultProps = {\n    component: StyledTooltip,\n    delay: 300,\n    mousePosition: 'bottom',\n    position: 'bottom',\n    tag: 'div'\n  };\n  return Tooltip;\n}(React.Component);\n\nexport { Tooltip as TooltipWithoutAnalytics };\nvar createAndFireEventOnAtlaskit = createAndFireEvent('atlaskit');\nexport default withAnalyticsContext({\n  componentName: 'tooltip',\n  packageName: packageName,\n  packageVersion: packageVersion\n})(withAnalyticsEvents({\n  onHide: unhoveredPayload,\n  onShow: createAndFireEventOnAtlaskit(__assign({}, hoveredPayload))\n})(Tooltip));","map":null,"metadata":{},"sourceType":"module"}